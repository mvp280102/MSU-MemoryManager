#pragma once


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>


// Структура, представляющая дескриптор блока памяти:
struct mem_handle_t
{
	int addr;               // адрес размещения блока относительно начала всей памяти в байтах
	int size;               // размер блока в байтах

	mem_handle_t(int addr, int size) : addr(addr), size(size) {}

	bool operator == (const mem_handle_t& other) const { return other.addr == addr && other.size == size; }
	bool operator != (const mem_handle_t& other) const { return !operator == (other); }
};

// Структура менеджера памяти:
typedef struct
{
	/*
	 * Создает менеджер памяти.
	 * size:
	 * для менеджеров памяти - размер всей памяти в байтах
	 * для garbage collection - максимальное количество объектов
	 * для страничных менеджеров - размер одной страницы памяти
	 * num_pages:
	 * для страничных менеджеров - количество физических страниц
	 * Возвращаемое значение: 1 - успех, 0 - неудача.
	 */
	int (*create)(int size, int num_pages);

	/*
	 * Удаляет менеджер памяти.
	 * Возвращаемое значение: 1 - успех, 0 - неудача (например, менеждер не был создан).
	 */
	int (*destroy)();


	// Менеджеры памяти:

	/*
	 * Выделяет блок памяти размером block_size байт.
	 * Для менеджеров памяти с фиксированным размером блока памяти аргумент функции игнорируется.
	 * Возвращаемое значение: дескриптор выделенного блока - успех, нулевой дескриптор {0,0} - неудача.
	 */
	mem_handle_t (*alloc)(int block_size);

	/*
	 * Освобождает блок памяти с дескриптором h.
	 * Возвращаемое значение: 1 - успех, 0 - неудача (например, неверный дескриптор).
	 * Стековый менеджер должен игнорировать параметр h и всегда освобождать последний выделенный блок.
	 */
	int (*free)(mem_handle_t h);

	/*
	 * Возвращает дескриптор выделенного блока памяти, целиком содержащего указанный регион.
	 * В случае, если такого блока не существует, возвращается нулевой дескриптор {0,0}.
	 */
	mem_handle_t (*get_block)(int addr, int size);

	/*
	 * Возвращает максимальный размер блока памяти (в байтах), который может быть сейчас выделен.
	 */
	int (*get_max_block_size)();

	/*
	 * Возвращает суммарный объем свободной памяти в байтах.
	 */
	int (*get_free_space)();

	/*
	 * Выводит все выделенные блоки памяти в формате <аddr> <size>.
	 * Порядок блоков - по возрастанию адресов.
	 */
	void (*print_blocks)();


	// Garbage collection:

	/*
	 * Создает объект.
	 * Длина имени объекта ограничена 32 символами.
	 * Возвращаемое значение: 1 - успех, 0 - неудача.
	 */
	int (*create_object)(const char* name);

	/*
	 * Уничтожает объект.
	 * При этом удаляются все исходящие из объекта ссылки.
	 * Объект задается своим именем.
	 * Возвращаемое значение: 1 - успех, 0 - неудача.
	 */
	int (*destroy_object)(const char* name);

	/*
	 * Выводит имена всех созданных и не уничтоженных объектов в алфавитном порядке.
	 */
	void (*print_objects)();

	/*
	 * Делает объект с заданным именем корневым.
	 * Допускается существование множества корневых объектов.
	 * Возвращаемое значение: 1 - успех, 0 - неудача.
	 */
	int (*set_root)(const char* name);

	/*
	 * Создает ссылку из объекта object1 на объект object2.
	 * Количество ссылок из каждого объекта ограничено числом 16.
	 * Возвращаемое значение: 1 - успех, 0 - неудача.
	 */
	int (*link)(const char* object1_name, const char* object2_name);

	/*
	 * Вычисляет и выводит множество живых объектов.
	 * Живыми считаются объекты типа root (корневые), а также
	 * все объекты, доступные из других живых объектов по ссылкам.
	 * Вывод объектов осуществляется в алфавитном порядке.
	 */
	void (*collect_live_objects)(void);

	/*
	 * Вычисляет и печатает множество мертвых ссылок в объектах, т.е. ссылок,
	 * указывающих на удаленные объекты. Для этого ведется учет всех объектов,
	 * созданных и удаленных с помощью create_object() и destroy_object().
	 * Формат вывода ссылки: <object1_name>, <ref_num>.
	 * Вывод осуществляется после упорядочивания объектов в алфавитном порядке,
	 * а потом по номеру ссылки по возрастанию.
	 */
	void (*collect_dead_links)(void);

	/*
	 * Для каждого объекта выводит количество ссылок на него.
	 * Считаются только ссылки, ведущие из не удаленных объектов.
	 * Формат вывода: <object_name> <link_count>.
	 * Вывод объектов осуществляется в алфавитном порядке.
	 */
	void (*print_link_counts)();


	// Paging:

	/*
	 * Записывает страницу физической памяти real_page в файл с именем
	 * page_<virtual_page>. Данные записываются в бинарном формате.
	 * В случае успеха выводит на экран сообщение: save_page <real_page> <virtual_page>.
	 * Возвращаемое значение: 1 - успех, 0 - неудача.
	 */
	int (*save_page)(int real_page, int virtual_page);

	/*
	 * Считывает из файла с именем page_<virtual_page> страницу памяти и загружает
	 * ее в физическую страницу real_page. Данные считываются в бинарном формате.
	 * Если файл с таким именем отсутствует, физическая страница заполняется нулями.
	 * В случае успеха выводит на экран сообщение: load_page <virtual_page> <real_page>.
	 * Возвращаемое значение: 1 - успех, 0 - неудача.
	 */
	int (*load_page)(int virtual_page, int real_page);

	/*
	 * Записывает по указанному виртуальному адресу addr указанное значение (байт) val.
	 * В случае, если соответствующая виртуальная страница отсутствует в памяти, данные не записываются.
	 * Возвращаемое значение: 1 - успех, 2 - виртуальная страница отсутствует, 0 - неудача (например, адрес меньше 0).
	 */
	int (*set_byte)(int addr, char val);

	/*
	 * Считывает значение (байт) из ячейки виртуальной памяти, расположенной по указанному адресу addr, и кладет в буфер dst.
	 * Возвращаемое значение: 1 - успех, 2 - виртуальная страница отсутствует, 0 - неудача (например, адрес меньше 0).
	 */
	int (*get_byte)(int addr, char *dst);

	/*
	 * Возвращает номер виртуальной страницы памяти, содержащей указанный блок.
	 * Возвращаемое значение: номер страницы - успех, -1 - неудача.
	 */
	int (*page_num)(mem_handle_t block);

	/*
	 * Инициирует обращение к памяти типа чтение.
	 * В случае успеха метод выводит на экран сообщение в формате: read <addr> <size> <ppa>,
	 * где ppa - номер физической страницы, к которой происходит обращение.
	 * Сами данные копировать не требуется.
	 * Возвращаемое значение: 1 - успех, -1 - неудача.
	 */
	int (*read)(int addr, int size);

	/*
	 * Инициирует обращение к памяти типа запись.
	 * В случае успеха метод выводит на экран сообщение в формате: write <addr> <size> <ppa>,
	 * где ppa - номер физической страницы, к которой происходит обращение.
	 * Сами данные копировать не требуется.
	 * Возвращаемое значение: 1 - успех, -1 - неудача.
	 */
	int (*write)(int addr, int size);

} memory_manager_t;


// Вспомогательные функции:

/*
 * Настаивает менеджер памяти перед началом работы.
 */
void setup_memory_manager(memory_manager_t* mm);